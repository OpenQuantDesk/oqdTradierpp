/*
/        oqdTradierpp - Full featured Tradier API library 
/       
/        Authors:  Benjamin Cance (kc8bws@kc8bws.com), OQD Developer Team (developers@openquantdesk.com)
/        Version:           v1.0.0
/        Release Date:  06/30/2025
/        License: Apache 2.0
/        Disclaimer: This software is provided "as-is" without warranties of any kind. 
/                    Use at your own risk. The authors are not liable for any trading losses.
/                    Not financial advice. By using this software, you accept all risks.
/
*/

#include "../include/oqdTradierpp/field_reference.hpp"
#include <mutex>
#include <regex>

namespace oqd {

std::once_flag FieldReference::fields_initialized_;

// Validation patterns
namespace ValidationPatterns {
    const std::string SYMBOL_PATTERN = R"(^[A-Z]{1,5}$)";
    const std::string OPTION_SYMBOL_PATTERN = R"(^[A-Z]{1,5}\d{6}[CP]\d{8}$)";
    const std::string DATE_PATTERN = R"(^\d{4}-\d{2}-\d{2}$)";
    const std::string DATETIME_PATTERN = R"(^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z?$)";
    const std::string EXCHANGE_CODE_PATTERN = R"(^[A-Z]$)";
    const std::string ORDER_ID_PATTERN = R"(^\d+$)";
    const std::string ACCOUNT_ID_PATTERN = R"(^[A-Z0-9]+$)";
}

// Exchange codes from reference data
namespace ExchangeCodes {
    const std::vector<std::string> EQUITY_EXCHANGES = {
        "A", "B", "C", "D", "E", "F", "I", "J", "K", "L", "M", "N", "P", "Q", 
        "S", "T", "U", "V", "W", "X", "G", "Y", "Z"
    };
    
    const std::vector<std::string> OPTION_EXCHANGES = {
        "A", "B", "C", "H", "I", "M", "N", "O", "P", "Q", "T", "W", "X", "Z"
    };
    
    bool is_valid_equity_exchange(const std::string& code) {
        return std::find(EQUITY_EXCHANGES.begin(), EQUITY_EXCHANGES.end(), code) != EQUITY_EXCHANGES.end();
    }
    
    bool is_valid_option_exchange(const std::string& code) {
        return std::find(OPTION_EXCHANGES.begin(), OPTION_EXCHANGES.end(), code) != OPTION_EXCHANGES.end();
    }
    
    std::string get_exchange_description(const std::string& code) {
        static std::unordered_map<std::string, std::string> descriptions = {
            {"A", "NYSE MKT"},
            {"B", "NASDAQ OMX BX"},
            {"C", "National Stock Exchange"},
            {"D", "FINRA ADF"},
            {"E", "Market Independent (Generated by Nasdaq SIP)"},
            {"F", "Mutual Funds/Money Markets (NASDAQ)"},
            {"I", "International Securities Exchange"},
            {"J", "Direct Edge A"},
            {"K", "Direct Edge X"},
            {"L", "Long Term Stock Exchange"},
            {"M", "Chicago Stock Exchange"},
            {"N", "NYSE"},
            {"P", "NYSE Arca"},
            {"Q", "NASDAQ OMX"},
            {"S", "NASDAQ Small Cap"},
            {"T", "NASDAQ Int"},
            {"U", "OTCBB"},
            {"V", "OTC other"},
            {"W", "CBOE"},
            {"X", "NASDAQ OMX PSX"},
            {"G", "GLOBEX"},
            {"Y", "BATS Y-Exchange"},
            {"Z", "BATS"}
        };
        
        auto it = descriptions.find(code);
        return (it != descriptions.end()) ? it->second : "Unknown Exchange";
    }
}

// Order validation constants from reference data
namespace OrderValidation {
    const std::vector<std::string> VALID_ORDER_STATUSES = {
        "open", "partially_filled", "filled", "expired", "canceled", "pending", "rejected", "error"
    };
    
    const std::vector<std::string> VALID_EQUITY_SIDES = {
        "buy", "buy_to_cover", "sell", "sell_short"
    };
    
    const std::vector<std::string> VALID_OPTION_SIDES = {
        "buy_to_open", "buy_to_close", "sell_to_open", "sell_to_close"
    };
    
    const std::vector<std::string> VALID_ORDER_TYPES = {
        "market", "limit", "stop", "stop_limit", "debit", "credit", "even"
    };
    
    const std::vector<std::string> VALID_ORDER_DURATIONS = {
        "day", "pre", "post", "gtc"
    };
    
    const std::vector<std::string> VALID_ORDER_CLASSES = {
        "equity", "option", "combo", "multileg"
    };
    
    const std::vector<std::string> VALID_STRATEGIES = {
        "freeform", "covered_call", "protective_put", "strangle", "straddle", 
        "spread", "collar", "butterfly", "condor", "unknown"
    };
    
    bool is_valid_order_status(const std::string& status) {
        return std::find(VALID_ORDER_STATUSES.begin(), VALID_ORDER_STATUSES.end(), status) != VALID_ORDER_STATUSES.end();
    }
    
    bool is_valid_order_side(const std::string& side, const std::string& security_type) {
        if (security_type == "equity") {
            return std::find(VALID_EQUITY_SIDES.begin(), VALID_EQUITY_SIDES.end(), side) != VALID_EQUITY_SIDES.end();
        } else if (security_type == "option") {
            return std::find(VALID_OPTION_SIDES.begin(), VALID_OPTION_SIDES.end(), side) != VALID_OPTION_SIDES.end();
        }
        return false;
    }
    
    bool is_valid_order_type(const std::string& type) {
        return std::find(VALID_ORDER_TYPES.begin(), VALID_ORDER_TYPES.end(), type) != VALID_ORDER_TYPES.end();
    }
    
    bool is_valid_duration(const std::string& duration) {
        return std::find(VALID_ORDER_DURATIONS.begin(), VALID_ORDER_DURATIONS.end(), duration) != VALID_ORDER_DURATIONS.end();
    }
    
    bool is_valid_order_class(const std::string& order_class) {
        return std::find(VALID_ORDER_CLASSES.begin(), VALID_ORDER_CLASSES.end(), order_class) != VALID_ORDER_CLASSES.end();
    }
    
    bool is_valid_strategy(const std::string& strategy) {
        return std::find(VALID_STRATEGIES.begin(), VALID_STRATEGIES.end(), strategy) != VALID_STRATEGIES.end();
    }
}

// Helper function to create order field definitions
std::unordered_map<std::string, FieldInfo> FieldReference::create_order_fields() {
    std::unordered_map<std::string, FieldInfo> fields;
    
    fields["id"] = FieldInfo{
        "id", "Unique identifier for the order", FieldType::String, true,
        {ValidationConstraint{ValidationRule::Required, "", "Order ID is required"},
         ValidationConstraint{ValidationRule::Pattern, ValidationPatterns::ORDER_ID_PATTERN, "Invalid order ID format"}},
        "12345", {}, "identification"
    };
    
    fields["type"] = FieldInfo{
        "type", "Order type - Single-leg: market, limit, stop, stop_limit; Multi-leg: market, debit, credit, even", 
        FieldType::Enum, true,
        {ValidationConstraint{ValidationRule::Required, "", "Order type is required"},
         ValidationConstraint{ValidationRule::OneOf, OrderValidation::VALID_ORDER_TYPES, "Invalid order type"}},
        "limit", OrderValidation::VALID_ORDER_TYPES, "order_details"
    };
    
    fields["symbol"] = FieldInfo{
        "symbol", "Security symbol or underlying security symbol", FieldType::String, true,
        {ValidationConstraint{ValidationRule::Required, "", "Symbol is required"},
         ValidationConstraint{ValidationRule::Pattern, ValidationPatterns::SYMBOL_PATTERN, "Invalid symbol format"},
         ValidationConstraint{ValidationRule::MinLength, 1, "Symbol cannot be empty"},
         ValidationConstraint{ValidationRule::MaxLength, 5, "Symbol too long"}},
        "AAPL", {}, "identification"
    };
    
    fields["side"] = FieldInfo{
        "side", "Order side - Equity: buy, buy_to_cover, sell, sell_short; Option: buy_to_open, buy_to_close, sell_to_open, sell_to_close", 
        FieldType::Enum, true,
        {ValidationConstraint{ValidationRule::Required, "", "Order side is required"}},
        "buy", {}, "order_details"
    };
    
    fields["quantity"] = FieldInfo{
        "quantity", "Number of shares or contracts", FieldType::Integer, true,
        {ValidationConstraint{ValidationRule::Required, "", "Quantity is required"},
         ValidationConstraint{ValidationRule::MinValue, 1, "Quantity must be at least 1"},
         ValidationConstraint{ValidationRule::MaxValue, 10000000, "Quantity cannot exceed 10,000,000"}},
        "100", {}, "order_details"
    };
    
    fields["status"] = FieldInfo{
        "status", "Order status", FieldType::Enum, true,
        {ValidationConstraint{ValidationRule::Required, "", "Status is required"},
         ValidationConstraint{ValidationRule::OneOf, OrderValidation::VALID_ORDER_STATUSES, "Invalid order status"}},
        "open", OrderValidation::VALID_ORDER_STATUSES, "status"
    };
    
    fields["duration"] = FieldInfo{
        "duration", "Order duration: day, pre, post, gtc", FieldType::Enum, true,
        {ValidationConstraint{ValidationRule::Required, "", "Duration is required"},
         ValidationConstraint{ValidationRule::OneOf, OrderValidation::VALID_ORDER_DURATIONS, "Invalid duration"}},
        "day", OrderValidation::VALID_ORDER_DURATIONS, "order_details"
    };
    
    fields["price"] = FieldInfo{
        "price", "Limit price", FieldType::Double, false,
        {ValidationConstraint{ValidationRule::MinValue, 0.0, "Price must be positive"}},
        "150.25", {}, "pricing"
    };
    
    fields["stop_price"] = FieldInfo{
        "stop_price", "Stop price", FieldType::Double, false,
        {ValidationConstraint{ValidationRule::MinValue, 0.0, "Stop price must be positive"}},
        "145.00", {}, "pricing"
    };
    
    fields["avg_fill_price"] = FieldInfo{
        "avg_fill_price", "Average fill price", FieldType::Double, false,
        {ValidationConstraint{ValidationRule::MinValue, 0.0, "Average fill price must be positive"}},
        "150.12", {}, "execution"
    };
    
    fields["exec_quantity"] = FieldInfo{
        "exec_quantity", "Total number of shares/contracts filled", FieldType::Integer, false,
        {ValidationConstraint{ValidationRule::MinValue, 0, "Exec quantity must be non-negative"}},
        "50", {}, "execution"
    };
    
    fields["last_fill_price"] = FieldInfo{
        "last_fill_price", "Last fill price", FieldType::Double, false,
        {ValidationConstraint{ValidationRule::MinValue, 0.0, "Last fill price must be positive"}},
        "150.15", {}, "execution"
    };
    
    fields["last_fill_quantity"] = FieldInfo{
        "last_fill_quantity", "Last fill quantity", FieldType::Integer, false,
        {ValidationConstraint{ValidationRule::MinValue, 0, "Last fill quantity must be non-negative"}},
        "25", {}, "execution"
    };
    
    fields["remaining_quantity"] = FieldInfo{
        "remaining_quantity", "Number of shares/contracts remaining", FieldType::Integer, false,
        {ValidationConstraint{ValidationRule::MinValue, 0, "Remaining quantity must be non-negative"}},
        "50", {}, "execution"
    };
    
    fields["create_date"] = FieldInfo{
        "create_date", "Date the order was created", FieldType::DateTime, true,
        {ValidationConstraint{ValidationRule::Required, "", "Create date is required"}},
        "2023-06-30T10:30:00Z", {}, "timestamps"
    };
    
    fields["transaction_date"] = FieldInfo{
        "transaction_date", "Date the order was last updated", FieldType::DateTime, false,
        {},
        "2023-06-30T10:35:00Z", {}, "timestamps"
    };
    
    fields["class"] = FieldInfo{
        "class", "Order class: equity, option, combo, multileg", FieldType::Enum, true,
        {ValidationConstraint{ValidationRule::Required, "", "Order class is required"},
         ValidationConstraint{ValidationRule::OneOf, OrderValidation::VALID_ORDER_CLASSES, "Invalid order class"}},
        "equity", OrderValidation::VALID_ORDER_CLASSES, "classification"
    };
    
    fields["strategy"] = FieldInfo{
        "strategy", "Order strategy", FieldType::Enum, false,
        {ValidationConstraint{ValidationRule::OneOf, OrderValidation::VALID_STRATEGIES, "Invalid strategy"}},
        "freeform", OrderValidation::VALID_STRATEGIES, "classification"
    };
    
    fields["option_symbol"] = FieldInfo{
        "option_symbol", "OCC option symbol", FieldType::String, false,
        {ValidationConstraint{ValidationRule::Pattern, ValidationPatterns::OPTION_SYMBOL_PATTERN, "Invalid option symbol format"}},
        "AAPL230630C00150000", {}, "options"
    };
    
    fields["reason_description"] = FieldInfo{
        "reason_description", "Rejection details", FieldType::String, false,
        {},
        "Insufficient buying power", {}, "status"
    };
    
    fields["tag"] = FieldInfo{
        "tag", "Order tag if available", FieldType::String, false,
        {},
        "user_tag_123", {}, "metadata"
    };
    
    return fields;
}

// Helper function to create balance field definitions  
std::unordered_map<std::string, FieldInfo> FieldReference::create_balance_fields() {
    std::unordered_map<std::string, FieldInfo> fields;
    
    fields["option_short_value"] = FieldInfo{
        "option_short_value", "Value of short option positions", FieldType::Double, false,
        {},
        "-1500.00", {}, "positions"
    };
    
    fields["total_equity"] = FieldInfo{
        "total_equity", "Total account value", FieldType::Double, true,
        {ValidationConstraint{ValidationRule::Required, "", "Total equity is required"}},
        "50000.00", {}, "equity"
    };
    
    fields["account_number"] = FieldInfo{
        "account_number", "Account number", FieldType::String, true,
        {ValidationConstraint{ValidationRule::Required, "", "Account number is required"},
         ValidationConstraint{ValidationRule::Pattern, ValidationPatterns::ACCOUNT_ID_PATTERN, "Invalid account number format"}},
        "123456789", {}, "identification"
    };
    
    fields["account_type"] = FieldInfo{
        "account_type", "Type of the account", FieldType::Enum, true,
        {ValidationConstraint{ValidationRule::Required, "", "Account type is required"},
         ValidationConstraint{ValidationRule::OneOf, std::vector<std::string>{"margin", "cash", "pdt"}, "Invalid account type"}},
        "margin", {"margin", "cash", "pdt"}, "identification"
    };
    
    fields["close_pl"] = FieldInfo{
        "close_pl", "Gain/Loss of current session's closed positions", FieldType::Double, false,
        {},
        "250.50", {}, "pnl"
    };
    
    fields["current_requirement"] = FieldInfo{
        "current_requirement", "Account's maintenance margin", FieldType::Double, false,
        {ValidationConstraint{ValidationRule::MinValue, 0.0, "Current requirement must be non-negative"}},
        "5000.00", {}, "margin"
    };
    
    fields["equity"] = FieldInfo{
        "equity", "Equity value", FieldType::Double, false,
        {ValidationConstraint{ValidationRule::MinValue, 0.0, "Equity must be non-negative"}},
        "45000.00", {}, "equity"
    };
    
    fields["long_market_value"] = FieldInfo{
        "long_market_value", "Long market value", FieldType::Double, false,
        {},
        "30000.00", {}, "positions"
    };
    
    fields["market_value"] = FieldInfo{
        "market_value", "Market value", FieldType::Double, false,
        {},
        "48000.00", {}, "positions"
    };
    
    fields["open_pl"] = FieldInfo{
        "open_pl", "Total gain/loss of current account's positions", FieldType::Double, false,
        {},
        "1250.75", {}, "pnl"
    };
    
    fields["option_long_value"] = FieldInfo{
        "option_long_value", "Value of long option positions", FieldType::Double, false,
        {},
        "2500.00", {}, "positions"
    };
    
    fields["option_requirement"] = FieldInfo{
        "option_requirement", "Account's total option requirement", FieldType::Double, false,
        {ValidationConstraint{ValidationRule::MinValue, 0.0, "Option requirement must be non-negative"}},
        "1000.00", {}, "margin"
    };
    
    fields["pending_orders_count"] = FieldInfo{
        "pending_orders_count", "Count of all pending/open orders", FieldType::Integer, false,
        {ValidationConstraint{ValidationRule::MinValue, 0, "Pending orders count must be non-negative"}},
        "3", {}, "orders"
    };
    
    fields["short_market_value"] = FieldInfo{
        "short_market_value", "Short market value", FieldType::Double, false,
        {},
        "-5000.00", {}, "positions"
    };
    
    fields["stock_long_value"] = FieldInfo{
        "stock_long_value", "Value of long equity positions", FieldType::Double, false,
        {},
        "25000.00", {}, "positions"
    };
    
    fields["total_cash"] = FieldInfo{
        "total_cash", "Total cash in the account", FieldType::Double, false,
        {},
        "15000.00", {}, "cash"
    };
    
    fields["uncleared_funds"] = FieldInfo{
        "uncleared_funds", "Cash unavailable for trading in the account", FieldType::Double, false,
        {ValidationConstraint{ValidationRule::MinValue, 0.0, "Uncleared funds must be non-negative"}},
        "500.00", {}, "cash"
    };
    
    fields["pending_cash"] = FieldInfo{
        "pending_cash", "Amount of cash being held for open orders", FieldType::Double, false,
        {ValidationConstraint{ValidationRule::MinValue, 0.0, "Pending cash must be non-negative"}},
        "1000.00", {}, "cash"
    };
    
    return fields;
}

// Additional field creation functions would follow similar patterns...
// For brevity, I'll implement a few key ones and the main interface functions

std::unordered_map<std::string, FieldInfo> FieldReference::create_position_fields() {
    std::unordered_map<std::string, FieldInfo> fields;
    
    fields["cost_basis"] = FieldInfo{
        "cost_basis", "Cost of the position", FieldType::Double, true,
        {ValidationConstraint{ValidationRule::Required, "", "Cost basis is required"}},
        "15000.50", {}, "financial"
    };
    
    fields["date_acquired"] = FieldInfo{
        "date_acquired", "Date position was acquired (or most recently updated)", FieldType::Date, false,
        {},
        "2023-06-15", {}, "dates"
    };
    
    fields["id"] = FieldInfo{
        "id", "Unique position identifier", FieldType::String, true,
        {ValidationConstraint{ValidationRule::Required, "", "Position ID is required"}},
        "pos_12345", {}, "identification"
    };
    
    fields["quantity"] = FieldInfo{
        "quantity", "Number of shares/contracts (positive=long, negative=short)", FieldType::Double, true,
        {ValidationConstraint{ValidationRule::Required, "", "Quantity is required"}},
        "100.0", {}, "quantity"
    };
    
    fields["symbol"] = FieldInfo{
        "symbol", "Security symbol", FieldType::String, true,
        {ValidationConstraint{ValidationRule::Required, "", "Symbol is required"},
         ValidationConstraint{ValidationRule::Pattern, ValidationPatterns::SYMBOL_PATTERN, "Invalid symbol format"}},
        "AAPL", {}, "identification"
    };
    
    return fields;
}

std::unordered_map<std::string, FieldInfo> FieldReference::create_quote_fields() {
    std::unordered_map<std::string, FieldInfo> fields;
    
    fields["symbol"] = FieldInfo{
        "symbol", "Security symbol for the quote", FieldType::String, true,
        {ValidationConstraint{ValidationRule::Required, "", "Symbol is required"},
         ValidationConstraint{ValidationRule::Pattern, ValidationPatterns::SYMBOL_PATTERN, "Invalid symbol format"}},
        "AAPL", {}, "identification"
    };
    
    fields["bid"] = FieldInfo{
        "bid", "Bid price", FieldType::Double, false,
        {ValidationConstraint{ValidationRule::MinValue, 0.0, "Bid price must be positive"}},
        "150.25", {}, "pricing"
    };
    
    fields["ask"] = FieldInfo{
        "ask", "Ask price", FieldType::Double, false,
        {ValidationConstraint{ValidationRule::MinValue, 0.0, "Ask price must be positive"}},
        "150.30", {}, "pricing"
    };
    
    fields["last"] = FieldInfo{
        "last", "Last trade price", FieldType::Double, false,
        {ValidationConstraint{ValidationRule::MinValue, 0.0, "Last price must be positive"}},
        "150.28", {}, "pricing"
    };
    
    fields["volume"] = FieldInfo{
        "volume", "Trading volume", FieldType::Integer, false,
        {ValidationConstraint{ValidationRule::MinValue, 0, "Volume must be non-negative"}},
        "1234567", {}, "volume"
    };
    
    return fields;
}

// Placeholder implementations for other field types
std::unordered_map<std::string, FieldInfo> FieldReference::create_historical_fields() {
    return {}; // Implementation would follow similar pattern
}

std::unordered_map<std::string, FieldInfo> FieldReference::create_gain_loss_fields() {
    return {}; // Implementation would follow similar pattern
}

std::unordered_map<std::string, FieldInfo> FieldReference::create_history_fields() {
    return {}; // Implementation would follow similar pattern
}

std::unordered_map<std::string, FieldInfo> FieldReference::create_access_token_fields() {
    return {}; // Implementation would follow similar pattern
}

std::unordered_map<std::string, FieldInfo> FieldReference::create_clock_fields() {
    return {}; // Implementation would follow similar pattern
}

std::unordered_map<std::string, FieldInfo> FieldReference::create_calendar_fields() {
    return {}; // Implementation would follow similar pattern
}

std::unordered_map<std::string, FieldInfo> FieldReference::create_watchlist_fields() {
    return {}; // Implementation would follow similar pattern
}

std::unordered_map<std::string, FieldInfo> FieldReference::create_symbol_search_fields() {
    return {}; // Implementation would follow similar pattern
}

std::unordered_map<std::string, FieldInfo> FieldReference::create_streaming_fields() {
    return {}; // Implementation would follow similar pattern
}

// Main interface implementation
const std::unordered_map<ResponseType, std::unordered_map<std::string, FieldInfo>>& FieldReference::get_all_field_maps() {
    static std::unordered_map<ResponseType, std::unordered_map<std::string, FieldInfo>> all_fields;
    static std::once_flag initialized;
    
    std::call_once(initialized, []() {
        all_fields[ResponseType::Order] = create_order_fields();
        all_fields[ResponseType::AccountBalances] = create_balance_fields();
        all_fields[ResponseType::Position] = create_position_fields();
        all_fields[ResponseType::Quote] = create_quote_fields();
        all_fields[ResponseType::Historical] = create_historical_fields();
        all_fields[ResponseType::GainLoss] = create_gain_loss_fields();
        all_fields[ResponseType::History] = create_history_fields();
        all_fields[ResponseType::AccessToken] = create_access_token_fields();
        all_fields[ResponseType::Clock] = create_clock_fields();
        all_fields[ResponseType::Calendar] = create_calendar_fields();
        all_fields[ResponseType::Watchlist] = create_watchlist_fields();
        all_fields[ResponseType::SymbolSearch] = create_symbol_search_fields();
        all_fields[ResponseType::Streaming] = create_streaming_fields();
    });
    
    return all_fields;
}

void FieldReference::initialize_field_maps() {
    // Force initialization by calling the getter
    get_all_field_maps();
}

const std::unordered_map<std::string, FieldInfo>& FieldReference::get_fields(ResponseType type) {
    const auto& all_fields = get_all_field_maps();
    auto it = all_fields.find(type);
    if (it != all_fields.end()) {
        return it->second;
    }
    static std::unordered_map<std::string, FieldInfo> empty;
    return empty;
}

const FieldInfo& FieldReference::get_field_info(ResponseType type, const std::string& field_name) {
    const auto& fields = get_fields(type);
    auto it = fields.find(field_name);
    if (it != fields.end()) {
        return it->second;
    }
    static FieldInfo unknown_field{"unknown", "Unknown field", FieldType::String, false};
    return unknown_field;
}

bool FieldReference::is_field_required(ResponseType type, const std::string& field_name) {
    return get_field_info(type, field_name).required;
}

std::vector<std::string> FieldReference::get_required_fields(ResponseType type) {
    std::vector<std::string> required;
    const auto& fields = get_fields(type);
    for (const auto& [name, info] : fields) {
        if (info.required) {
            required.push_back(name);
        }
    }
    return required;
}

bool FieldReference::field_exists(ResponseType type, const std::string& field_name) {
    const auto& fields = get_fields(type);
    return fields.find(field_name) != fields.end();
}

FieldType FieldReference::get_field_type(ResponseType type, const std::string& field_name) {
    return get_field_info(type, field_name).type;
}

std::vector<std::string> FieldReference::get_valid_values(ResponseType type, const std::string& field_name) {
    return get_field_info(type, field_name).valid_values;
}

// Field validation utilities
bool FieldValidator::validate_string_length(const std::string& value, int min_length, int max_length) {
    int len = static_cast<int>(value.length());
    return len >= min_length && len <= max_length;
}

bool FieldValidator::validate_numeric_range(double value, double min_val, double max_val) {
    return value >= min_val && value <= max_val;
}

bool FieldValidator::validate_pattern(const std::string& value, const std::string& pattern) {
    try {
        std::regex regex_pattern(pattern);
        return std::regex_match(value, regex_pattern);
    } catch (const std::regex_error&) {
        return false;
    }
}

bool FieldValidator::validate_enum_value(const std::string& value, const std::vector<std::string>& valid_values) {
    return std::find(valid_values.begin(), valid_values.end(), value) != valid_values.end();
}

bool FieldValidator::is_valid_symbol_format(const std::string& symbol) {
    return validate_pattern(symbol, ValidationPatterns::SYMBOL_PATTERN);
}

bool FieldValidator::is_valid_option_symbol(const std::string& option_symbol) {
    return validate_pattern(option_symbol, ValidationPatterns::OPTION_SYMBOL_PATTERN);
}

bool FieldValidator::is_valid_exchange_code(const std::string& exchange) {
    return validate_pattern(exchange, ValidationPatterns::EXCHANGE_CODE_PATTERN);
}

// String conversion functions
std::string to_string(FieldType type) {
    switch (type) {
        case FieldType::String: return "String";
        case FieldType::Integer: return "Integer";
        case FieldType::Double: return "Double";
        case FieldType::Boolean: return "Boolean";
        case FieldType::Date: return "Date";
        case FieldType::DateTime: return "DateTime";
        case FieldType::Enum: return "Enum";
        case FieldType::Array: return "Array";
        case FieldType::Object: return "Object";
        case FieldType::Optional: return "Optional";
        default: return "Unknown";
    }
}

std::string to_string(ValidationRule rule) {
    switch (rule) {
        case ValidationRule::Required: return "Required";
        case ValidationRule::MinLength: return "MinLength";
        case ValidationRule::MaxLength: return "MaxLength";
        case ValidationRule::MinValue: return "MinValue";
        case ValidationRule::MaxValue: return "MaxValue";
        case ValidationRule::Pattern: return "Pattern";
        case ValidationRule::OneOf: return "OneOf";
        case ValidationRule::Range: return "Range";
        case ValidationRule::PositiveNumber: return "PositiveNumber";
        case ValidationRule::NonEmpty: return "NonEmpty";
        default: return "Unknown";
    }
}

std::string to_string(ResponseType type) {
    switch (type) {
        case ResponseType::Order: return "Order";
        case ResponseType::AccountBalances: return "AccountBalances";
        case ResponseType::Position: return "Position";
        case ResponseType::Quote: return "Quote";
        case ResponseType::Historical: return "Historical";
        case ResponseType::GainLoss: return "GainLoss";
        case ResponseType::History: return "History";
        case ResponseType::AccessToken: return "AccessToken";
        case ResponseType::Clock: return "Clock";
        case ResponseType::Calendar: return "Calendar";
        case ResponseType::Watchlist: return "Watchlist";
        case ResponseType::SymbolSearch: return "SymbolSearch";
        case ResponseType::OptionChain: return "OptionChain";
        case ResponseType::TimeSales: return "TimeSales";
        case ResponseType::Streaming: return "Streaming";
        default: return "Unknown";
    }
}

} // namespace oqd